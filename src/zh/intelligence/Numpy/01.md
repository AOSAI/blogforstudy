---
title: Numpy之熬炼筋骨
order: 1
author: AOSAI
date: 2023-11-14
category:
  - 机器学习
tag:
  - 机器学习
  - Numpy
---

## 1. 数组基础

### 1.1 创建数组

在 Numpy 中数组叫做 ndarrays，可能是 n dim array（n 维数组）的意思。

```py
import numpy as np
1-dim = np.array([0,1,2,3,4])
2-dim = np.array([[0,1,2,3],[4,5,6,7]])
3-dim = np.array([[[0,1],[2,3]],[[1,2],[3,4]]])
```

在这个例子中我们可以看出 Numpy 数组理论上是可以无限嵌套的，它的维度就是嵌套的次数。

另外，我们还可以把序列传递给 Numpy 中的 array()函数，这个序列不仅仅指的是 Python 中的列表（list），只要是类数组型的数据都可以传递。

```py
import numpy as np
arr1 = [1,2,3,4,5]
arr2 = np.array(arr1)

arr3 = np.arange(5)  # [0,1,2,3,4]
arr4 = np.linspace(0,2*np.pi,5)  # [0, 1.57079633, 3.14159265, 4.71238898, 6.28318531]
```

其实我最开始很疑惑，为什么 np 中的数组，还要里面加 [] 中括号。最后发现，在 arr1 传递的过程中，它打印出来的列表类型就是 [1，2，3，4，5] 这样子一个状态，所以如果要像 1-dim 一样，直接创建的话，就需要遵循列表性质，加上 [] 。

**arange([start], stop, [step], [dtype])** 就像写了一个 range 的列表推导式，也是序列，所以可以这样生成数组，<u>表示返回给定间隔内的均匀间隔的值</u>，[] 中括号内的表示可以省略的。

**linspace(start, stop, [num], [endpoint], [restep], [dtype])** <u>返回指定间隔内的等间隔数字</u>，因为终点 stop 为 2\*np.pi = 6.28，生成的数量 num 为 5，所以解决就如代码注释所示。

### 1.2 数组切片

我们先看一些 Python 中常见的切片操作：

```py
b = [1,2,3,4,5]

print(b[1:])  # 从第二个取到最后一个 [2,3,4,5]
print(b[:3])  # 从头截取到第三个 [1,2,3]
print(b[:-1]) # 从头到倒数第二个 [1,2,3,4]

print(b[0:4:2]) # 从头截取到第四个，步长为2，[1,3]
print(b[::-1]) # 不设开头不设结尾，步长为-1，因此从后往前输出全部，[5,4,3,2,1]
print(b[2::-1]) # 从下标为二的元素翻转读取，[3,2,1]
```

然后我们用 Numpy 创建一个二维数组，来进行切片操作：

```py
a = np.array([[11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20],
              [21, 22, 23, 24, 25],
              [26, 27, 28 ,29, 30],
              [31, 32, 33, 34, 35]])
print(a[2, 4])  # 25
print(a[0, 1:4])  # [12, 13, 14]
print(a[1:4, 0])  # [16, 21, 26]
print(a[::2, ::2])  # [[11, 13, 15],[21, 23, 25],[31, 33, 35]]
print(a[:, 1])  # [12, 17, 22, 27, 32]
```

我们选择元素的方式和 Python 相同，a[2，4] 表示选择第 3 行，第 5 列的元素，就是 25。记住==前行后列==这四个字就成。另外数组的索引是从 0 开始的，所以我们说第几行第几列的时候就要 +1，2+1=3，4+1=5，新手易错点。

切片 n:m 表示从第 n 个索引开始，切取到第 m-1 个索引处。在高级编程语言中，基本上这种有范围限制的，都是前闭后开的，还是索引的原因，假如我们说第 5 个元素是最后一个元素，但是它的索引其实是 4，所以必须要 -1。a[0，1:4] 就表示第一行，截取索引 0~3 的元素，就是 [12，13，14] 。

如果 : 单独作为占位符使用，就表示==忽略行或列==，因为它完整的样子是 start : end，只有一个冒号时就表示不设起始值，不设结束值。就比如 a[:, 1] 表示忽略行、选择第二列。a[::2, ::2]，行步长为 2，列步长为 2，选择元素。

### 1.3 数组属性

还是以刚才的二维数组 a 为例，我们看看它的属性有哪些：

```py
print(type(a))  # 数组类型：<class 'numpy.ndarray'>
print(a.dtype)  # 数据类型：int64
print(a.size)  # 数组长度：25
print(a.shape)  # 数组形状：(5, 5)。表示 5行 5列。
print(a.itemsize)  # 每个元素占用的字节数：8
print(a.ndim)  # 数组维数：2
print(a.nbytes)  # 数组的所有数据消耗掉的字节数：200
```

这里要稍微说明一下的是，int64 表示有 64 位，一个字节 8 位，因此一个元素占用 8 个字节。另外 shape 同样也可以表示维数，（x，）这样就表示一维；（x，y）这样表示二维，（x，y，z）这样就表示三维。

## 2. 数组进阶

### 2.1 创建数组

进阶的创建数组最常见的就是重塑形状，比如先创建一个 1 维数组，然后给它重塑为 2 维数组、或 3 维数组等等。再有就是比如我们通过随机数函数来创建数组。

::: tabs

@tab 重塑二维数组

```py
import numpy as np
# 表示生成一个0到19的一维数组，然后变形为 4 行 5 列的二维数组
array1 = np.arange(20).reshape(4,5)
# array2 和 array1 是等价的
array2 = np.array([[ 0,  1,  2,  3,  4],
                   [ 5,  6,  7,  8,  9],
                   [10, 11, 12, 13, 14],
                   [15, 16, 17, 18, 19]])
```

@tab 重塑三维数组

```py
import numpy as np
# 表示生成一个 0 到 26 的一维数组，然后将其塑性为 3 × 3 × 3 的三维数组
array1 = np.arange(27).reshape(3,3,3)
# array2 和 array1 是等价的
array2 = np.array([[[ 0,  1,  2], [ 3,  4,  5], [ 6,  7,  8]],
                   [[ 9, 10, 11], [12, 13, 14], [15, 16, 17]],
                   [[18, 19, 20], [21, 22, 23], [24, 25, 26]]])
```

@tab 随机数函数创建数组

```py
import numpy as np
# 表示生成一个 2 × 2 的二维随机数数组，取值范围 [0, 1]
array = np.random.random((2,2))
# 因为是随机的，所以每次结果都不一样，这里举个例子
print(array)
# [[0.1632794 , 0.34567049],
#  [0.03463241, 0.70687903]]
```

:::

除了变形和随机数，我们还有一些常见的创建、填充数组的函数，比如：

1. 使用 zeros() 函数创建一个填充 0 的数组，函数的参数表示行数和列数。
2. 使用 ones() 函数创建一个填充 1 的数组，参数同上。
3. empty() 函数创建一个数组，它的初始内容是随机的，取决于内存的状态。
4. full() 函数创建一个填充给定值的 n \* n 的数组。
5. eye() 函数可以创建一个 n \* n 的单位矩阵。

```py
import numpy as np

np.zeros((2,4)) == np.array([[0., 0., 0., 0.],
                             [0., 0., 0., 0.]])

np.ones((3,4)) == np.array([[1., 1., 1., 1.],
                            [1., 1., 1., 1.],
                            [1., 1., 1., 1.]])

np.empty((2,3)) == np.array([[0.65670626, 0.52097334, 0.99831087],
                             [0.07280136, 0.4416958 , 0.06185705]])

np.full((2,2), 3) == np.array([[3, 3],
                               [3, 3]])

np.eye(3,3) == np.array([[1., 0., 0.],
                         [0., 1., 0.],
                         [0., 0., 1.]])
```

总结一下基础篇和进阶篇，Numpy 创建数组有三种不同的机制：

1. 从其他 Python 结构（例如，列表，元组）转换
2. numpy 原生数组的创建（例如，arange、ones、zeros 等）
3. 使用特殊库函数（例如，random）

除了列举出来的这些，还有很多创建方式，这里直接给到相关 API：[Numpy 创建数组 API](https://www.numpy.org.cn/reference/routines/array-creation.html)

### 2.2 基本操作符

```py
a = np.array([[0,1,2],[3,4,5],[6,7,8]])
b = np.array([[10,62,1],[56,79,2],[14,2,45]])

a + b == np.add(a, b)       # 对应元素相加
a - b == np.subtract(a, b)  # 对应元素相减
a * b == np.multiply(a, b)  # 对应元素相乘
a / b == np.divide(a, b)    # 对应元素相除

a ** 2      # 元素分别平方
a < b       # 对应元素比较，小于时为真返回 True，大于等于时为假返回 False
np.sqrt(x)  # 元素分别开根号
a.T         # 向量转置
a.dot(b) == np.dot(a, b)
```

dot()函数称为点积，也叫内积。向量内积或者说矩阵内积，必须要满足的条件就是，前一个向量的列数要与后一个向量的行数要对应，否则没有办法相乘。简单的写一下：

$$
\begin{bmatrix} 1 & 2 & 3  \end{bmatrix} \cdot
\begin{bmatrix} 4 \\ 5 \\ 6 \end{bmatrix} = 4 + 10 + 18 = 32
$$

这里前一个行向量的列数是 3，后一个列向量的行数是 3，==点积的相乘规律就是前行乘后列==，因此相加就等于 32。再看一下反过来的：

$$
\begin{bmatrix} 4 \\ 5 \\ 6 \end{bmatrix} \cdot
\begin{bmatrix} 1 & 2 & 3  \end{bmatrix} =
\begin{bmatrix} 4 & 8 & 12 \\ 5 & 10 & 15 \\ 6 & 12 & 18 \end{bmatrix}
$$

列向量点乘行向量，前行乘后列，就变成了一个矩阵。

### 2.3 特殊运算符

除了基本的运算符，Numpy 还提供了一些好用的处理数组的函数。

```py
a = np.arange(10)
print(a.sum())  # 数组元素相加：45
print(a.min())  # 数组元素中的最小值：0
print(a.max())  # 数组元素中的最大值：9
print(a.cumsum())
```

cumsum() 这个函数很有意思，乍一看很像斐波那契数列，但其实不是，它是从索引 0 开始，走到哪（n），就把 0 到 n 的元素全部累加：

a[0] = 0
a[1] = 0 + 1 = 1
a[2] = 0 + 1 + 2 = 3
a[3] = 0 + 1 + 2 + 3 = 6
a[4] = 0 + 1 + 2 + 3 + 4 = 10

## 3. 索引进阶

### 3.1 花式索引

它是指我们可以通过数组来存储指定索引，从而获取指定元素的方法。在 Python 中这样是不可行的，只能单独取一个，所以这个操作确实挺花哨的。

```py
a = np.arange(0, 100, 10)
# [ 0 10 20 30 40 50 60 70 80 90]
indices = [1, 5, -1]
# indices 表示存储索引为1，5，-1。a[indices] 则是搜索这三个索引的值
b = a[indices]
# [10 50 90]
```

### 3.2 缺省索引 & 条件选择

缺省索引其实就是切片，这个在基础篇写的很详细。重点是条件选择，这个我在 Python 里确实没见到过，直接这样写条件判断的，说列表推导式吧，也不像，反正记住这个就行了。

```py
a = np.arange(0, 100, 10)
# [ 0 10 20 30 40 50 60 70 80 90]
b = a[:5]
c = a[a >= 50]
print(b) # >>>[ 0 10 20 30 40]
print(c) # >>>[50 60 70 80 90]
```

### 3.3 Where 函数

这个比起条件选择来看着更正规一点，同样也是根据条件返回数组中的值的有效方法，唯一要注意的就是他返回的是一个元组，[0] 索引的位置才是返回的列表本体。

```py
a = np.arange(0, 100, 10)
# [ 0 10 20 30 40 50 60 70 80 90]
b = np.where(a < 50)
c = np.where(a >= 50)[0]
print(b) # >>>(array([0, 1, 2, 3, 4]),)
print(c) # >>>[5 6 7 8 9]
```

### 3.4 布尔屏蔽

这里稍微有点朝纲，Matplotlib 具体会另起一个文档编写。不过也不是什么大事儿，学习的过程就是模仿嘛，多看多写就会了。

```py
import numpy as np
import matplotlib.pyplot as plt

a = np.linspace(0, 2 * np.pi, 50)
b = np.sin(a)
plt.plot(a,b)
mask = b >= 0
plt.plot(a[mask], b[mask], 'bo')
mask = (b >= 0) & (a <= np.pi / 2)
plt.plot(a[mask], b[mask], 'go')
plt.show()
```

这里画了一个图，plot(a, b) 中的 a 就表示横坐标，是 0 到 2Π 的长度，b 表示纵坐标，相当于画了一个 sin(a) 的函数。

mask 是这节的重点，布尔屏蔽，它会根据指定的条件检索数组中的元素。“bo” 和 “go” 这两个缩写词也困扰我好久，翻了文档才知道，b 表示 blue，g 表示 green，o 表示 circle marker。这样一解释，看到出来的图，对应代码就好理解了。[pyplot.plot 的官方文档](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html)

![1.1 布尔屏蔽](/matplotlib&numpy/numpy-01.png =560x)

代码中存在两个 mask 屏蔽判断，前一个是要 y > 0，蓝色的圆点表示，第二个是在第一个的基础上，还要 x < Π/2，绿色圆点表示，我们可以看到后一个的绿色把前一个蓝色是覆盖掉了的。

## 4. 矩阵和向量

### 4.1 向量的构建

一般情况下，我们说的向量都是列向量。最简单的构建思路就是，二维数组，每行元素就一个：

```py
v1 = np.array([[3],[1],[-2]])
```

但是这样写，如果数量太多了，就很麻烦，更方便的方法是转置相应的行向量，两种写法：

```py
v1 = np.array([[3,1,-2]])
v2 = np.transpose(v1)
v3 = v1.T
```

向量的内积运算以及切片等操作前边已经讲过了，这里不赘述了。

### 4.2 求解方程组

线性代数中常见问题之一就是求解矩阵向量方程：$A\cdot{\vec{x}}=\vec{b}$，当 $A$ 和 $\vec{b}$ 等于如下值时，求解 $\vec{x}$：

$$
A=\begin{bmatrix} 2&1&-2 \\ 3&0&1 \\ 1&1&-1 \end{bmatrix} \qquad
\vec{b}=\begin{bmatrix} -3 \\ 5 \\ -2 \end{bmatrix}
$$

```py
# 先构建 A 和 b 的数组
A = np.array([[2,1,-2],[3,0,1],[1,1,-1]])
b = np.transpose(np.array([[-3,5,-2]]))

# 求解
x = np.linalg.solve(A,b)
```

除了求解方程组，还有很多其他线性代数相关的函数，这里附上 API 链接：[线性代数 numpy.linalg 相关 API](https://www.numpy.org.cn/reference/routines/linalg.html)

### 4.3 广播

广播是一种强大的==机制==，它允许 numpy 在执行算术运算时使用不同形状的数组。这个听起来很高端，但是写起来很简单。我们举个例子，假设我们有 1 个矩阵和 1 个向量，矩阵 x 有 4 行 3 列，向量 v 是一个行向量，如下代码表示：

```py
import numpy as np
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
```

我们如果要向矩阵 x 的每一行都加上一个向量 v，该怎么做？

1. 如果是原始 Python，我想大概就是循环操作。
2. Numpy 有一种方法可以将向量复制扩充变成矩阵，这样就成了矩阵加法。
3. 直接利用广播机制，进行相加。

```py
# 循环累加
y = np.empty_like(x)  # 创建一个和 x 一样的新矩阵
for i in range(4):
    y[i, :] = x[i, :] + v
print(y)

# 扩充向量成矩阵
vv = np.tile(v, (4, 1))
y = x + vv
print(y)

# 利用广播机制
y = x + v
print(y)
```

**np.tile(A, reps)：** 只有两个参数，第一个参数 A 就是要进行复制的原始向量，也就是输入，要注意的是第二个参数，如果直接写数字的话，就是 1 维扩充，三个元素的行向量变成了六个元素的行向量，而（x，y，z……）的这种形式，就好像 shape，你要告诉它扩充成什么形状的。

广播机制就是你直接用加法，它的底层逻辑自动帮你扩充成相同的形状。当然了，扩充也是有规则约束的：

1. 如果数组不具有相同的 rank，则将较低等级数组的形状添加 1，直到两个形状具有相同的长度。
2. 如果两个数组在维度上具有相同的大小，或者如果其中一个数组在该维度中的大小为 1，则称这两个数组在维度上是兼容的。
3. 如果数组在所有维度上兼容，则可以一起广播。
4. 广播之后，每个数组的行为就好像它的形状等于两个输入数组的形状的元素最大值。
5. 在一个数组的大小为 1 且另一个数组的大小大于 1 的任何维度中，第一个数组的行为就像沿着该维度复制一样
